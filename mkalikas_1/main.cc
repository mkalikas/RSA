#include <iostream>#include <fstream>#include <cstdio>#include <cstdlib>#include <cstring>#include <string>#include <sys/stat.h>#include "sha256.h"#include "BigIntegerLibrary.hh"/*  This function inputs a file that has the contents.  Either the file containing the secret key or public key will be passed to this function.  It also takes in the sha256 hash of a message.  Returns a string of the encrypted/decrypted message.*/const std::string cryptomessage(std::string key_filename, BigUnsigned base) {  std::ifstream input_key(key_filename.c_str());  std::string key, n; // strings to hold the values extracted from the file  for(int i = 0; i < 2; ++i) {    if(i == 0)      std::getline(input_key, key); // the first line in the file is e or d    else     std::getline(input_key, n); // the second line in the file is n  }  input_key.close();  /// Encrypt/decrypt using the hash using the key  return bigUnsignedToString(modexp(BigInteger(base), stringToBigUnsigned(key), stringToBigUnsigned(n)));}/*  The string passed is a filename that is read into a character array.  The array is passed into the cryptomessage function.  The signature is generated and written to a new file that is the name of the original file with .signature extension*/void generate_signature(std::string filename) {  std::ifstream infile(filename.c_str(), std::ios::binary | std::ios::ate);  while(!infile.is_open())    return;  std::streampos size;  size = infile.tellg();  infile.seekg(0, std::ios::beg);  char* memblock = new char[size];  infile.read (memblock, size); //read the entire file  std::string base(memblock);  base = sha256(base);  infile.close();  std::ofstream outfile("signature.signed", std::ios::binary);  // Writes the contents of the original file to the signed file  outfile.write(memblock, size);  // Make call to cryptomessage to get the decrypted string of memblock  std::string decrypt = cryptomessage("d_n.txt", BigUnsignedInABase(base, 16)); // pass the file holding the private key and n  char* signature = new char[decrypt.length()]; // character array to hold the signature  strcpy(signature, decrypt.c_str()); // copy the decrypted string into the character array  outfile.write(signature, decrypt.length()); // write the signature to the file  outfile.close();  filename = filename+".signed";  std::ofstream out(filename.c_str(), std::ios::binary);  out.write(signature, decrypt.length());  delete [] memblock;  delete [] signature;}/* Takes two strings, one representing the name of the file to be checked and the second of the signature of the contents.  Returns true if the document is authentic, and false otherwise.  If false, encrypting signature will not be the same as the check file to be read.*/bool verify_signature(std::string check, std::string signature) {  std::ifstream infile(check.c_str(), std::ios::binary | std::ios::ate);  while(!infile.is_open())    return false;  std::streampos size;  size = infile.tellg();  infile.seekg(0, std::ios::beg);  char* memblock = new char[size];  infile.read (memblock, size); //read the entire file  infile.close();  std::ifstream infile2(signature.c_str(), std::ios::binary | std::ios::ate);  while(!infile2.is_open())    return false;  std::streampos length;  length = infile2.tellg();  infile2.seekg(0, std::ios::beg);  char* sig = new char[length];  infile2.read (sig, length); //read the entire file  std::string s(sig);  infile2.close();  std::string signature_encrypt = cryptomessage("e_n.txt", BigUnsignedInABase(s, 16)); // String that holds the signature encrypted  std::string content_encrypt = cryptomessage("d_n.txt", BigUnsignedInABase(sha256(static_cast<std::string>(memblock)), 32));  content_encrypt = cryptomessage("e_n.txt", BigUnsignedInABase(content_encrypt, 16));    delete [] memblock;  delete [] sig;  // Compare strings and return if they are equal  return (!signature_encrypt.compare(content_encrypt)); // compares the check to the encrypted version of it and returns if they are the same}int main(int argc, char *argv[]){  try {    switch (*argv[1]) {      case 's':        generate_signature(argv[2]);        break;      case 'v':        if(!verify_signature(argv[2], argv[3]))          std::cout << "The document is authentic\n";         else          std::cout << "The document is modified\n";      default:        return 0;    }  } catch(char const* err) {    std::cout << "The library threw an exception:\n"      << err << std::endl;  }}